# SSR/SSG 프로젝트 작업 명세서

## 프로젝트 개요

본 프로젝트는 Vanilla JavaScript와 React를 사용하여 Server-Side Rendering(SSR)과 Static Site Generation(SSG)을 구현하는 것이 목표입니다.

### 프로젝트 구조
- **packages/vanilla**: Vanilla JavaScript 기반 SSR/SSG 구현
- **packages/react**: React 기반 SSR/SSG 구현
- **packages/lib**: 공통 라이브러리 (Router, Store 등)

---

## 기본과제: Vanilla SSR & SSG

### 1. Express SSR 서버 구현

#### 1.1 Express 미들웨어 기반 서버 구현
**현재 상태**: 기본적인 Express 서버 구조만 존재 (`packages/vanilla/server.js`)

**작업 내용**:
- [ ] Express 정적 파일 서빙 설정 (`express.static`)
- [ ] 개발 환경: Vite 빌드 결과물 서빙
- [ ] 프로덕션 환경: 빌드된 정적 파일 서빙
- [ ] HTML 템플릿 파일 읽기 및 처리 (`index.html`)

**작업 파일**:
- `packages/vanilla/server.js`

**작업 방법**:
```javascript
// 개발 환경에서는 Vite 개발 서버와 연동
// 프로덕션 환경에서는 빌드된 파일 사용
if (prod) {
  app.use(express.static('dist/vanilla'));
} else {
  // Vite 미들웨어 또는 프록시 설정
}
```

#### 1.2 개발/프로덕션 환경 분기 처리
**현재 상태**: 환경 변수는 선언되어 있으나 활용되지 않음

**작업 내용**:
- [ ] `NODE_ENV`를 기반으로 분기 로직 구현
- [ ] 개발 환경: Vite 개발 서버 연동 또는 HMR 지원
- [ ] 프로덕션 환경: 빌드된 파일 사용

**작업 방법**:
```javascript
const prod = process.env.NODE_ENV === "production";
const isDev = !prod;

if (isDev) {
  // 개발 환경 설정
  // Vite 미들웨어 또는 프록시
} else {
  // 프로덕션 환경 설정
  // 정적 파일 서빙
}
```

#### 1.3 HTML 템플릿 치환
**현재 상태**: 하드코딩된 HTML 사용

**작업 내용**:
- [ ] `index.html` 파일 읽기
- [ ] `<!--app-html-->` 플레이스홀더를 서버 렌더링된 HTML로 치환
- [ ] `<!--app-head-->` 플레이스홀더를 메타 정보로 치환

**작업 방법**:
```javascript
// HTML 템플릿 읽기
const template = fs.readFileSync('index.html', 'utf-8');

// 서버에서 렌더링한 HTML 생성
const appHtml = await render(url, query);

// 치환
const html = template
  .replace('<!--app-html-->', appHtml)
  .replace('<!--app-head-->', headContent);
```

---

### 2. 서버 사이드 렌더링 (SSR)

#### 2.1 서버에서 동작하는 Router 구현
**현재 상태**: `packages/vanilla/src/main-server.js`에 기본 구조만 존재

**작업 내용**:
- [ ] 서버 사이드에서 동작하는 Router 구현
- [ ] URL 경로 파싱 및 라우트 매칭
- [ ] 동적 라우트 파라미터 추출 (`/products/:id`)

**작업 파일**:
- `packages/vanilla/src/main-server.js`
- `packages/vanilla/src/router/router.js` (확장 필요)

**작업 방법**:
```javascript
// main-server.js에서
export const render = async (url, query) => {
  // Router 인스턴스 생성
  const serverRouter = createServerRouter(url);
  
  // 현재 라우트 매칭
  const route = serverRouter.match(url);
  
  if (!route) {
    return '<div>404 Not Found</div>';
  }
  
  // 해당 라우트의 페이지 렌더링
  return await renderPage(route, query);
};
```

**참고사항**:
- 클라이언트 Router와 서버 Router의 일관성 유지
- 동적 라우트 파라미터 추출 로직 구현
- 복잡한 URL 패턴도 안정적으로 처리 가능해야 함

#### 2.2 서버 데이터 프리페칭
**작업 내용**:
- [ ] 상품 목록 페이지: `/` - 상품 목록 데이터 프리페칭
- [ ] 상품 상세 페이지: `/products/:id` - 상품 상세 데이터 프리페칭
- [ ] API 호출을 서버 사이드에서 수행

**작업 파일**:
- `packages/vanilla/src/main-server.js`
- `packages/vanilla/src/services/productService.js` (확장 필요)

**작업 방법**:
```javascript
export const render = async (url, query) => {
  const router = createServerRouter(url);
  const route = router.match(url);
  
  let initialState = {};
  
  // 라우트별 데이터 프리페칭
  if (route.path === '/') {
    // 홈페이지: 상품 목록 데이터
    const products = await fetchProductList(query);
    initialState = {
      productStore: {
        products: products.data,
        total: products.total
      }
    };
  } else if (route.path === '/products/:id') {
    // 상품 상세: 상품 상세 데이터
    const product = await fetchProductDetail(route.params.id);
    initialState = {
      productStore: {
        currentProduct: product
      }
    };
  }
  
  // 초기 상태로 스토어 초기화 후 렌더링
  return renderWithInitialState(route, initialState);
};
```

#### 2.3 서버 상태관리 초기화
**작업 내용**:
- [ ] 서버 사이드에서 Store 초기화
- [ ] 프리페칭한 데이터로 Store 상태 설정
- [ ] 초기화된 상태를 HTML에 포함시켜 전달

**작업 파일**:
- `packages/vanilla/src/main-server.js`
- `packages/vanilla/src/stores/*.js`

**작업 방법**:
```javascript
// 서버 사이드에서 Store 초기화
import { productStore, cartStore, uiStore } from './stores';

export const render = async (url, query) => {
  // Store 초기화
  productStore.init(initialProductState);
  cartStore.init(initialCartState);
  uiStore.init(initialUIState);
  
  // 라우트에 맞는 페이지 렌더링
  const html = await renderPage(url);
  
  // 초기 상태 추출
  const initialState = {
    productStore: productStore.getState(),
    cartStore: cartStore.getState(),
    uiStore: uiStore.getState()
  };
  
  return { html, initialState };
};
```

---

### 3. 클라이언트 Hydration

#### 3.1 `window.__INITIAL_DATA__` 스크립트 주입
**작업 내용**:
- [ ] 서버에서 생성한 초기 상태를 `window.__INITIAL_DATA__`에 주입
- [ ] HTML 템플릿에 스크립트 태그로 포함

**작업 파일**:
- `packages/vanilla/server.js`

**작업 방법**:
```javascript
// server.js에서
const { html, initialState } = await render(req.url, req.query);

const htmlWithData = template
  .replace('<!--app-html-->', html)
  .replace(
    '<!--app-head-->',
    `<script>window.__INITIAL_DATA__ = ${JSON.stringify(initialState)};</script>`
  );
```

#### 3.2 클라이언트 상태 복원
**작업 내용**:
- [ ] `main.js`에서 `window.__INITIAL_DATA__` 읽기
- [ ] 읽은 데이터로 Store 초기화
- [ ] Hydration 모드로 렌더링 시작

**작업 파일**:
- `packages/vanilla/src/main.js`

**작업 방법**:
```javascript
// main.js에서
function main() {
  // 서버에서 전달된 초기 데이터 복원
  const initialState = window.__INITIAL_DATA__ || {};
  
  if (initialState.productStore) {
    productStore.init(initialState.productStore);
  }
  if (initialState.cartStore) {
    cartStore.init(initialState.cartStore);
  }
  if (initialState.uiStore) {
    uiStore.init(initialState.uiStore);
  }
  
  // 기존 초기화 로직
  registerAllEvents();
  registerGlobalEvents();
  loadCartFromStorage();
  
  // Hydration 모드로 렌더링 (기존 DOM에 이벤트만 바인딩)
  initRender();
  router.start();
}
```

#### 3.3 서버-클라이언트 데이터 일치
**작업 내용**:
- [ ] 서버에서 렌더링한 HTML과 클라이언트에서 렌더링한 HTML이 일치하는지 확인
- [ ] Hydration 불일치 오류 방지

**작업 방법**:
- 서버와 클라이언트에서 동일한 초기 상태 사용
- 렌더링 로직 일관성 유지
- 타임스탬프나 랜덤 값 등 불일치를 유발하는 요소 제거

---

### 4. Static Site Generation (SSG)

#### 4.1 동적 라우트 SSG
**작업 내용**:
- [ ] 상품 상세 페이지들을 빌드 타임에 미리 생성
- [ ] 모든 상품 ID에 대해 정적 HTML 파일 생성

**작업 파일**:
- `packages/vanilla/static-site-generate.js` (새로 생성)

**작업 방법**:
```javascript
// static-site-generate.js
import { fetchProductList } from './src/services/productService.js';
import { render } from './src/main-server.js';
import fs from 'fs';
import path from 'path';

async function generateStaticSite() {
  // 1. 홈페이지 생성
  const homeHtml = await render('/', {});
  fs.writeFileSync('dist/vanilla/index.html', homeHtml);
  
  // 2. 모든 상품 상세 페이지 생성
  const products = await fetchProductList({ limit: 1000 });
  
  for (const product of products.data) {
    const productHtml = await render(`/products/${product.id}`, {});
    const dir = path.join('dist/vanilla/products', product.id.toString());
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(path.join(dir, 'index.html'), productHtml);
  }
}
```

#### 4.2 빌드 타임 페이지 생성
**작업 내용**:
- [ ] `package.json`에 SSG 빌드 스크립트 추가
- [ ] 빌드 프로세스: 클라이언트 빌드 → SSG 생성

**작업 파일**:
- `packages/vanilla/package.json`
- `packages/vanilla/static-site-generate.js`

**작업 방법**:
```json
// package.json
{
  "scripts": {
    "build": "vite build && node static-site-generate.js",
    "build:client": "vite build",
    "build:ssg": "node static-site-generate.js"
  }
}
```

#### 4.3 파일 시스템 기반 배포
**작업 내용**:
- [ ] 생성된 정적 파일들을 `dist/vanilla` 디렉토리에 배치
- [ ] GitHub Pages 등 정적 호스팅에 배포 가능하도록 구성

**작업 방법**:
- `dist/vanilla/` 디렉토리 구조:
  ```
  dist/vanilla/
  ├── index.html (홈페이지)
  ├── products/
  │   ├── 1/
  │   │   └── index.html
  │   ├── 2/
  │   │   └── index.html
  │   └── ...
  └── assets/ (빌드된 JS/CSS)
  ```

---

## 심화과제: React SSR & SSG

### 1. React SSR

#### 1.1 `renderToString` 서버 렌더링
**현재 상태**: `packages/react/server.js`에 기본 구조만 존재

**작업 내용**:
- [ ] `react-dom/server`의 `renderToString` 사용
- [ ] React 컴포넌트를 서버에서 렌더링

**작업 파일**:
- `packages/react/server.js`
- `packages/react/src/main-server.tsx`

**작업 방법**:
```typescript
// main-server.tsx
import { renderToString } from 'react-dom/server';
import { App } from './App';

export const render = async (url: string, query: Record<string, string>) => {
  // 서버에서 React 앱 렌더링
  const html = renderToString(<App url={url} query={query} />);
  return html;
};

// server.js에서
import { render } from './dist/react-ssr/main-server.js';

app.get('*', async (req, res) => {
  const html = await render(req.url, req.query);
  // HTML 템플릿에 삽입
});
```

#### 1.2 TypeScript SSR 모듈 빌드
**작업 내용**:
- [ ] SSR용 TypeScript 파일 빌드 설정
- [ ] Vite의 SSR 빌드 기능 활용

**작업 파일**:
- `packages/react/vite.config.ts`
- `packages/react/package.json`

**작업 방법**:
```json
// package.json
{
  "scripts": {
    "build:server": "vite build --outDir ./dist/react-ssr --ssr src/main-server.tsx"
  }
}
```

**주의사항**:
- SSR 빌드와 클라이언트 빌드 분리
- Node.js 환경에서 실행 가능하도록 설정
- 타입 정의 정확성 확인

#### 1.3 Universal React Router (서버/클라이언트 분기)
**작업 내용**:
- [ ] 서버와 클라이언트에서 모두 동작하는 Router 구현
- [ ] 환경에 따라 다른 초기화 방식 사용

**작업 파일**:
- `packages/react/src/router/router.ts`
- `packages/react/src/main-server.tsx`
- `packages/react/src/main.tsx`

**작업 방법**:
```typescript
// router.ts
export const createRouter = (isServer: boolean) => {
  if (isServer) {
    // 서버 사이드 Router
    return createServerRouter();
  } else {
    // 클라이언트 사이드 Router
    return createClientRouter();
  }
};

// main-server.tsx
const router = createRouter(true); // 서버 모드
router.setPath(url);

// main.tsx
const router = createRouter(false); // 클라이언트 모드
router.start();
```

**주의사항**:
- 메모리 누수 방지 (서버에서는 이벤트 리스너 정리)
- 성능 최적화 (서버에서는 불필요한 기능 제거)

#### 1.4 React 상태관리 서버 초기화
**작업 내용**:
- [ ] React Context 또는 Store를 서버에서 초기화
- [ ] 초기 상태를 클라이언트로 전달

**작업 방법**:
```typescript
// 서버에서
const initialState = {
  products: await fetchProducts(),
  // ...
};

const html = renderToString(
  <StoreProvider initialState={initialState}>
    <App />
  </StoreProvider>
);

// 클라이언트에서
const initialState = window.__INITIAL_DATA__;
createRoot(root).render(
  <StoreProvider initialState={initialState}>
    <App />
  </StoreProvider>
);
```

---

### 2. React Hydration

#### 2.1 Hydration 불일치 방지
**작업 내용**:
- [ ] 서버와 클라이언트 렌더링 결과 일치 보장
- [ ] `suppressHydrationWarning` 사용 최소화
- [ ] 랜덤 값, 타임스탬프 등 클라이언트 전용 값 제거

**작업 방법**:
- 서버와 클라이언트에서 동일한 데이터 사용
- 조건부 렌더링 시 서버/클라이언트 구분 제거
- React DevTools의 Hydration 경고 확인

#### 2.2 클라이언트 상태 복원
**작업 내용**:
- [ ] `window.__INITIAL_DATA__`에서 상태 복원
- [ ] Hydration 후 클라이언트 라우팅 활성화

**작업 방법**:
```typescript
// main.tsx
const initialState = window.__INITIAL_DATA__ || {};

function main() {
  const rootElement = document.getElementById('root')!;
  createRoot(rootElement).render(
    <StoreProvider initialState={initialState}>
      <App />
    </StoreProvider>
  );
  
  router.start(); // Hydration 후 라우팅 시작
}
```

---

### 3. React SSG

#### 3.1 동적 라우트 SSG (상품 상세 페이지들)
**작업 내용**:
- [ ] 모든 상품 상세 페이지를 빌드 타임에 생성
- [ ] React 컴포넌트를 HTML로 렌더링하여 저장

**작업 파일**:
- `packages/react/static-site-generate.js`

**작업 방법**:
```javascript
// static-site-generate.js
import { renderToString } from 'react-dom/server';
import { render } from './dist/react-ssr/main-server.js';

async function generateStaticSite() {
  // 모든 상품 페이지 생성
  const products = await fetchProductList({ limit: 1000 });
  
  for (const product of products.data) {
    const html = await render(`/products/${product.id}`, {});
    // 파일로 저장
    fs.writeFileSync(
      `dist/react/products/${product.id}/index.html`,
      html
    );
  }
}
```

#### 3.2 빌드 타임 페이지 생성
**작업 내용**:
- [ ] `package.json`에 SSG 빌드 스크립트 추가
- [ ] 빌드 순서: 클라이언트 빌드 → SSR 빌드 → SSG 생성

**작업 방법**:
```json
// package.json
{
  "scripts": {
    "build": "pnpm run build:client && pnpm run build:server && pnpm run build:ssg",
    "build:client": "vite build",
    "build:server": "vite build --ssr src/main-server.tsx",
    "build:ssg": "node static-site-generate.js"
  }
}
```

#### 3.3 파일 시스템 기반 배포
**작업 내용**:
- [ ] 생성된 정적 파일들을 `dist/react` 디렉토리에 배치
- [ ] GitHub Pages 배포 가능하도록 구성

---

## 작업 순서 및 우선순위

### 1단계: 기본 인프라 구축
1. Express SSR 서버 기본 구조 완성
2. HTML 템플릿 치환 로직 구현
3. 개발/프로덕션 환경 분기 처리

### 2단계: Vanilla SSR 구현
1. 서버 Router 구현
2. 서버 데이터 프리페칭
3. 서버 상태관리 초기화
4. 클라이언트 Hydration 구현

### 3단계: Vanilla SSG 구현
1. SSG 빌드 스크립트 작성
2. 동적 라우트 페이지 생성
3. 빌드 및 배포 테스트

### 4단계: React SSR 구현
1. React SSR 모듈 빌드 설정
2. `renderToString` 구현
3. Universal Router 구현
4. React 상태관리 서버 초기화

### 5단계: React Hydration
1. Hydration 불일치 방지
2. 클라이언트 상태 복원

### 6단계: React SSG 구현
1. React SSG 빌드 스크립트 작성
2. 동적 라우트 페이지 생성
3. 최종 빌드 및 배포

---

## 테스트 체크리스트

### Vanilla SSR 테스트
- [ ] 서버에서 HTML이 정상적으로 렌더링되는지 확인
- [ ] 클라이언트 Hydration이 정상적으로 동작하는지 확인
- [ ] 서버와 클라이언트의 데이터가 일치하는지 확인
- [ ] 라우팅이 정상적으로 동작하는지 확인

### Vanilla SSG 테스트
- [ ] 빌드 타임에 모든 페이지가 생성되는지 확인
- [ ] 생성된 정적 파일들이 정상적으로 서빙되는지 확인
- [ ] 상품 상세 페이지들이 모두 접근 가능한지 확인

### React SSR 테스트
- [ ] React 컴포넌트가 서버에서 정상적으로 렌더링되는지 확인
- [ ] TypeScript 빌드 오류가 없는지 확인
- [ ] Universal Router가 서버/클라이언트에서 모두 동작하는지 확인

### React SSG 테스트
- [ ] React SSG 빌드가 정상적으로 완료되는지 확인
- [ ] 생성된 정적 페이지들이 정상적으로 동작하는지 확인

---

## 주의사항 및 고려사항

### 성능 고려사항
- 대용량 데이터(1000개 이상 상품) 처리 시 메모리 사용량 확인
- SSG 빌드 시간 최적화
- 서버 렌더링 응답 시간 최적화

### 타입 안정성
- TypeScript SSR 모듈의 타입 정의 정확성
- 서버/클라이언트 타입 일관성 유지

### 에러 처리
- 서버 렌더링 중 에러 발생 시 적절한 에러 페이지 표시
- SSG 빌드 중 에러 처리

### 보안
- `window.__INITIAL_DATA__`에 민감한 정보 포함하지 않기
- XSS 공격 방지를 위한 데이터 sanitization

---

## 참고 자료

- Express.js 공식 문서
- React Server Components 문서
- Vite SSR 가이드
- Playwright E2E 테스트 가이드

