# 개발 서버 vs 프로덕션 서버 차이점 및 동작 방식

## 개요

이 문서는 Vanilla SSR 서버의 개발 모드(`dev:ssr`)와 프로덕션 모드(`preview:ssr`) 간의 차이점과 각 서버의 동작 방식을 설명합니다.

## 문제 상황

- **기본 테스트**: 모두 성공 ✅
- **프로덕션 SSR 서버 (4174)**: 테스트 실패 ❌
  - URL: `http://localhost:4174/front_7th_chapter4-1/vanilla/`
  - 테스트: `SSR에서 초기 데이터가 window.__INITIAL_DATA__에 포함된다`

## 서버 모드별 설정

### 개발 서버 (`dev:ssr`)

**실행 명령어:**
```bash
pnpm run dev:ssr
```

**환경 변수:**
- `NODE_ENV`: 설정되지 않음 (기본값: `undefined`)
- `PORT`: `5174` (기본값)
- `BASE`: 설정되지 않음 (기본값: `"/"`)

**코드 설정 (`server.js`):**
```javascript
const prod = process.env.NODE_ENV === "production"; // false
const port = process.env.PORT || 5174; // 5174
const base = process.env.BASE || (prod ? "/front_7th_chapter4-1/vanilla/" : "/"); // "/"
```

**미들웨어 등록:**
```javascript
app.use(ssrMiddleware); // 루트 경로에 등록
```

**렌더링 함수 경로:**
```javascript
// 개발: 소스 파일 직접 import
const serverModule = await import("./src/main-server.js");
render = serverModule.render;
```

**정적 파일 서빙:**
```javascript
// /src, /public 경로에 정적 파일 서빙
app.use("/src", sirv(path.join(__dirname, "src"), { dev: true }));
app.use("/public", sirv(path.join(__dirname, "public"), { dev: true }));
```

### 프로덕션 서버 (`preview:ssr`)

**실행 명령어:**
```bash
pnpm run preview:ssr
```

**환경 변수:**
- `NODE_ENV`: `"production"`
- `PORT`: `4174`
- `BASE`: 설정되지 않음 (기본값: `"/front_7th_chapter4-1/vanilla/"`)

**코드 설정 (`server.js`):**
```javascript
const prod = process.env.NODE_ENV === "production"; // true
const port = process.env.PORT || 5174; // 4174
const base = process.env.BASE || (prod ? "/front_7th_chapter4-1/vanilla/" : "/"); // "/front_7th_chapter4-1/vanilla/"
```

**미들웨어 등록:**
```javascript
app.use(base, ssrMiddleware); // base 경로에 등록
```

**렌더링 함수 경로:**
```javascript
// 프로덕션: 빌드된 서버 모듈 사용
const serverModule = await import("./dist/vanilla-ssr/main-server.js");
render = serverModule.render;
```

**정적 파일 서빙:**
```javascript
// /assets 경로에만 정적 파일 서빙 (빌드된 파일)
app.use(
  base + "assets",
  sirv(path.join(distPath, "assets"), { dev: false })
);
```

## 핵심 차이점

### 1. Base 경로 처리

#### 개발 서버
- **Base 경로**: `"/"`
- **미들웨어 등록**: `app.use(ssrMiddleware)` - 루트 경로
- **요청 URL 예시**: `http://localhost:5174/`
- **`req.originalUrl`**: `"/"`
- **`req.path`**: `"/"`
- **전달되는 URL**: `"/"` (그대로 전달)

#### 프로덕션 서버
- **Base 경로**: `"/front_7th_chapter4-1/vanilla/"`
- **미들웨어 등록**: `app.use(base, ssrMiddleware)` - base 경로
- **요청 URL 예시**: `http://localhost:4174/front_7th_chapter4-1/vanilla/`
- **`req.originalUrl`**: `"/front_7th_chapter4-1/vanilla/"`
- **`req.path`**: `"/"` (Express가 base 경로 제거)
- **전달되는 URL**: `"/front_7th_chapter4-1/vanilla/"` (base 경로 포함하여 전달)

### 2. Express 미들웨어 동작

Express의 `app.use(path, middleware)`는 다음과 같이 동작합니다:

```javascript
// 개발 모드
app.use(ssrMiddleware);
// 모든 요청에 대해 ssrMiddleware 실행
// req.path = req.originalUrl (base 경로 없음)

// 프로덕션 모드
app.use("/front_7th_chapter4-1/vanilla/", ssrMiddleware);
// /front_7th_chapter4-1/vanilla/* 경로에만 ssrMiddleware 실행
// req.path = req.originalUrl에서 base 경로를 제거한 경로
```

**예시:**
- 요청: `http://localhost:4174/front_7th_chapter4-1/vanilla/`
- `req.originalUrl`: `"/front_7th_chapter4-1/vanilla/"`
- `req.path`: `"/"` (Express가 base 경로 제거)

### 3. URL 전달 로직

#### 수정 전 (문제 발생)

```javascript
// server.js (수정 전)
const url = req.originalUrl?.split("?")[0] || req.url.split("?")[0];
```

**문제점:**
- 개발 서버: `req.originalUrl = "/"` → 정상 작동 ✅
- 프로덕션 서버: `req.originalUrl = "/front_7th_chapter4-1/vanilla/"` → `main-server.js`의 `matchRoute`가 baseUrl을 제거하지만, URL 전달 방식이 일관되지 않음

#### 수정 후 (해결)

```javascript
// server.js (수정 후)
let url;
if (prod) {
  // 프로덕션: req.path는 base 경로가 제거된 경로이므로, base 경로를 다시 추가
  // main-server.js의 matchRoute가 baseUrl을 제거할 수 있도록 전체 경로 전달
  const pathWithoutBase = req.path || "/";
  url = base.replace(/\/$/, "") + pathWithoutBase;
} else {
  // 개발: 원본 URL 사용 (base 경로가 없으므로 그대로 사용)
  url = req.originalUrl?.split("?")[0] || req.url.split("?")[0];
}
```

**동작 방식:**
- 개발 서버: `req.originalUrl = "/"` → `url = "/"` → `matchRoute("/", "/")` → 정상 작동 ✅
- 프로덕션 서버: `req.path = "/"`, `base = "/front_7th_chapter4-1/vanilla/"` → `url = "/front_7th_chapter4-1/vanilla/"` → `matchRoute("/front_7th_chapter4-1/vanilla/", "/front_7th_chapter4-1/vanilla/")` → 정상 작동 ✅

### 4. main-server.js의 baseUrl 처리

```javascript
// main-server.js
const baseUrl = process.env.NODE_ENV === "production" 
  ? "/front_7th_chapter4-1/vanilla/" 
  : "/";

function matchRoute(url, baseUrl) {
  let pathname = url;
  if (baseUrl && pathname.startsWith(baseUrl)) {
    pathname = pathname.slice(baseUrl.length);
  }
  pathname = pathname.split("?")[0];
  if (!pathname.startsWith("/")) {
    pathname = "/" + pathname;
  }
  // ... 라우트 매칭 로직
}
```

**동작 예시:**

**개발 서버:**
- `url = "/"`, `baseUrl = "/"`
- `pathname = "/"` (baseUrl 제거 후)
- 라우트 매칭: 홈페이지 ✅

**프로덕션 서버:**
- `url = "/front_7th_chapter4-1/vanilla/"`, `baseUrl = "/front_7th_chapter4-1/vanilla/"`
- `pathname = "/"` (baseUrl 제거 후)
- 라우트 매칭: 홈페이지 ✅

## 수정 사항

### server.js 수정

**위치:** `packages/vanilla/server.js` (211-218줄)

**변경 내용:**
- 프로덕션 모드에서 `req.path`를 사용하여 base 경로가 제거된 경로를 얻음
- base 경로를 다시 추가하여 `main-server.js`의 `matchRoute`가 제거할 수 있도록 전체 경로 전달
- 개발 모드에서는 기존대로 `req.originalUrl` 사용

**코드:**
```javascript
let url;
if (prod) {
  // 프로덕션: req.path는 base 경로가 제거된 경로이므로, base 경로를 다시 추가
  const pathWithoutBase = req.path || "/";
  url = base.replace(/\/$/, "") + pathWithoutBase;
} else {
  // 개발: 원본 URL 사용
  url = req.originalUrl?.split("?")[0] || req.url.split("?")[0];
}
```

## 테스트 결과

### 수정 전
- 개발 서버 (5174): ✅ 통과
- 프로덕션 서버 (4174): ❌ 실패

### 수정 후
- 개발 서버 (5174): ✅ 통과
- 프로덕션 서버 (4174): ✅ 통과 (예상)

## 요약

1. **개발 서버**: Base 경로 없음 (`"/"`), 루트 경로에 미들웨어 등록
2. **프로덕션 서버**: Base 경로 있음 (`"/front_7th_chapter4-1/vanilla/"`), base 경로에 미들웨어 등록
3. **핵심 문제**: Express의 `app.use(base, middleware)`는 base 경로를 제거한 `req.path`를 제공하므로, 프로덕션에서 base 경로를 다시 추가하여 `main-server.js`에 전달해야 함
4. **해결 방법**: 프로덕션 모드에서 `req.path`를 사용하여 base 경로를 다시 추가한 전체 경로를 전달

## 참고 파일

- `packages/vanilla/server.js` - 서버 설정 및 미들웨어 등록
- `packages/vanilla/src/main-server.js` - SSR 렌더링 로직
- `packages/vanilla/package.json` - 스크립트 정의
- `e2e/createTests.ts` - 테스트 코드

