## 과제 체크포인트
[기본과제 : 바닐라](https://parksubeom.github.io/front_7th_chapter4-1/vanilla/)
[심화과제 : 리액트](https://parksubeom.github.io/front_7th_chapter4-1/react/)

### 배포 링크

<!--
배포 링크를 적어주세요
예시: https://<username>.github.io/front-7th-chapter4-1/

배포가 완료되지 않으면 과제를 통과할 수 없습니다.
배포 후에 정상 작동하는지 확인해주세요.
-->

### 기본과제 (Vanilla SSR & SSG)

#### Express SSR 서버
- [x] Express 미들웨어 기반 서버 구현
- [x] 개발/프로덕션 환경 분기 처리
- [x] HTML 템플릿 치환 (`<!--app-html-->`, `<!--app-head-->`)

#### 서버 사이드 렌더링
- [x] 서버에서 동작하는 Router 구현
- [x] 서버 데이터 프리페칭 (상품 목록, 상품 상세)
- [x] 서버 상태관리 초기화

#### 클라이언트 Hydration
- [x] `window.__INITIAL_DATA__` 스크립트 주입
- [x] 클라이언트 상태 복원
- [x] 서버-클라이언트 데이터 일치

#### Static Site Generation
- [x] 동적 라우트 SSG (상품 상세 페이지들)
- [x] 빌드 타임 페이지 생성
- [x] 파일 시스템 기반 배포

### 심화과제 (React SSR & SSG)

#### React SSR
- [x] `renderToString` 서버 렌더링
- [x] TypeScript SSR 모듈 빌드
- [x] Universal React Router (서버/클라이언트 분기)
- [x] React 상태관리 서버 초기화

#### React Hydration
- [x] Hydration 불일치 방지
- [x] 클라이언트 상태 복원

#### Static Site Generation
- [x] 동적 라우트 SSG (상품 상세 페이지들)
- [x] 빌드 타임 페이지 생성
- [x] 파일 시스템 기반 배포

## 아하! 모먼트 (A-ha! Moment)

<!--
과제를 진행하며 "아!" 하고 깨달음을 얻었던 순간이 있다면 공유해주세요.
어떤 부분에서 어려움을 겪다가, 어떤 계기로 개념이 명확해졌나요?
-->

## 자유롭게 회고하기

# 바닐라 JS로 SSR/SSG 구현하기: 프레임워크 없이 맨땅에서 시작한 여정

## 들어가며

"바닐라 자바스크립트로 SSR을 구현한다고?"

처음 과제 명세를 봤을 때 든 생각이다. React나 Next.js 같은 프레임워크가 자동으로 해주던 것들을 직접 만들어야 한다니. 솔직히 막막했다.

하지만 막상 시작하니 생각보다 훨씬 더 복잡했다. 그리고 그 과정에서 정말 많은 것들을 배웠다.

---

## 기술적 비유: 피자 주문으로 이해하는 렌더링 방식

복잡한 렌더링 개념을 '피자 배달'에 비유해서 정리해봤다.

### SSR (서버 사이드 렌더링): "새 피자 한 판을 통째로 다시 받는 방식"

**상황:** 쉬림프 피자를 먹다가 치킨 피자가 먹고 싶어지면 사장님께 "치킨 피자 한 판 새로 주세요!"라고 요청한다.

**방식:** 기존의 피자, 박스, 접시를 싹 치우고(새로고침), 새로 구운 피자를 통째로 다시 배달받는다.

**특징:** 매번 상을 갈아엎고 박스까지 새로 받아야 하니 배송 시간이 소요되지만, 오자마자 바로 먹을 수 있어 시각적으로는 빠르게 느껴진다.

### CSR (클라이언트 사이드 렌더링): "화덕을 집에 두고 토핑만 배달받는 방식"

**상황:** 처음에 미니 화덕(자바스크립트 엔진)과 기본 도우(HTML 틀)를 배달받는다. 처음엔 화덕을 설치하고 예열하느라 시간이 좀 걸린다(초기 로딩 느림).

**방식:** 치킨 피자가 먹고 싶어지면 "치킨 토핑(데이터)만 보내주세요!"라고 요청한다. 화덕과 도우는 그대로 둔 채, 위에 얹힌 토핑만 갈아 끼워 다시 굽는다.

**특징:** 빵과 박스를 새로 받을 필요가 없어 페이지 전환이 순식간에 일어난다.

### SSG (정적 사이트 생성): "인기 메뉴를 미리 구워둔 편의점 피자 방식"

**특징:** 주문이 들어오기 전, 사장님이 수백 종류의 피자를 미리 구워 진열대에 올려둔다. 주문 즉시 가져가기만 하면 되므로 응답 속도가 가장 빠르다.

---

## 과제 진행 과정

### 1단계: 서버 환경 구축 - "가게를 열어야 장사를 하지"

Express로 서버를 만드는 것 자체는 어렵지 않았다. 문제는 **"이 서버가 HTML을 어떻게 만들어 내보내야 하는가?"** 였다.

```javascript
// 처음 시도 - 실패
app.get('*', (req, res) => {
  res.send('<div id="root"></div>'); // 이게 다였다...
});

```

당연히 이렇게 하면 안 된다. 상품 데이터도, 스타일도, 아무것도 없는 텅 빈 HTML만 보내는 거니까.

**깨달음:** SSR은 단순히 HTML 파일을 보내는 게 아니라, **데이터가 채워진 완성된 HTML** 을 만들어서 보내야 한다.

### 2단계: 데이터 모킹 (MSW) - "재료가 없으면 가짜 재료라도"

실제 백엔드 API가 없으니 MSW(Mock Service Worker)로 가짜 API를 만들었다.

**예상치 못한 문제점:**

```javascript
// 브라우저에서는 잘 되는데...
setupWorker(handlers).start();

// 서버에서는?
setupServer(handlers).listen(); // 이거랑 다르다!?

```

같은 MSW인데 브라우저용(`setupWorker`)과 Node.js용(`setupServer`)이 따로 있었다. 처음엔 이걸 몰라서 서버에서 계속 404 에러가 났다.

**해결:** 환경에 따라 다른 MSW 설정을 사용하도록 분기 처리.

### 3단계: 라우팅과 데이터 패칭 - "주소에 따라 다른 요리를"

SPA 라우터를 만드는 건 생각보다 재미있었다. `window.history.pushState`와 `popstate` 이벤트를 활용하면 페이지 전환 없이도 주소를 바꿀 수 있다는 게 신기했다.

**가장 헷갈렸던 부분:**

```javascript
// 서버에서는 이렇게 하는데
const url = req.url; // '/products/123'

// 클라이언트에서는?
const url = window.location.pathname; // 똑같은데 왜 다르게 써야 하지?

```

서버와 클라이언트에서 URL을 읽는 방식이 달라서, 같은 로직을 양쪽에서 돌리려면 추상화가 필요했다.

### 4단계: 하이드레이션 - "식은 피자에 온기를 불어넣기"

하이드레이션(Hydration)이 뭔지 개념적으로는 알고 있었다. "서버에서 만든 HTML에 자바스크립트 이벤트를 붙이는 것"이라고.

**하지만 직접 구현하니 문제 투성이였다:**

1. **상태 불일치 문제**

```javascript
   // 서버에서 보낸 HTML
   <div>상품 개수: 340개</div>
   
   // 클라이언트가 다시 렌더링
   <div>상품 개수: 0개</div> // 어? 데이터가 안 왔네?

```

서버에서 렌더링할 때 사용한 데이터를 클라이언트에게도 전달해줘야 했다.

2. **이벤트 리스너 중복 문제**

```javascript
   // 서버에서 이미 HTML에 버튼이 있는데
   <button id="add-to-cart">담기</button>
   
   // 클라이언트가 또 렌더링하면?
   <button id="add-to-cart">담기</button> // 버튼이 두 개?!

```

**해결:**

```javascript
// 서버 데이터를 HTML에 심어서 전달
<script>
  window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};
</script>

// 클라이언트에서 읽어서 사용
const initialData = window.__INITIAL_DATA__;

```

### 5단계: SSG 빌드 자동화 - "340개 상품 페이지를 언제 다 만들어?"

상품이 340개인데, 각 상품마다 HTML 파일을 만들어야 한다. 수작업으로? 미쳤나?

SSR을 위해 만들어둔 렌더링 로직을 재사용해서, 빌드 타임에 HTML을 찍어내는 스크립트를 작성했다.

**자동화 스크립트 작성 (`build-ssg.js`):**

```javascript
import fs from "fs";
import { mswServer } from "./src/mocks/node.js"; // 2단계에서 만든 그 녀석

// 1. 빌드 타임에도 데이터가 필요하니 MSW를 켠다
mswServer.listen({ onUnhandledRequest: "warn" });

async function generateStaticSite() {
  // 기본 HTML 틀을 가져온다
  const template = await fs.promises.readFile(`./dist/vanilla/index.html`, "utf-8");
  
  // SSR용 렌더링 함수 동적 임포트
  const { render, getProducts } = await import(`./dist/vanilla-ssr/main-server.js`);

  // 홈, 404, 그리고 상품 20개(limit)에 대한 경로 리스트 생성
  const pages = await getPages(getProducts);

  for (const page of pages) {
    // 2. 각 페이지별로 HTML과 초기 데이터 생성
    const { html, head, initialData } = await render(page.url);
    
    // 3. 하이드레이션을 위한 데이터 스크립트 주입
    const initialDataScript = `<script>window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};</script>`;
    
    // 4. 템플릿 구멍 메우기 (치환)
    const result = template
      .replace("", html)
      .replace("", head)
      .replace("</head>", `${initialDataScript}</head>`);

    // 5. 파일로 저장 (예: /dist/product/1/index.html)
    const dir = page.filePath.split("/").slice(0, -1).join("/");
    await fs.promises.mkdir(dir, { recursive: true });
    await fs.writeFileSync(page.filePath, result);
  }
}

await generateStaticSite();
mswServer.close();

```

**구현하면서 챙겨야 했던 디테일:**

1. **MSW 재사용:** 빌드 스크립트도 결국 Node.js 환경이다. 여기서도 `setupServer`로 만든 MSW를 켜줘야 API 요청을 가로채서 데이터를 받아올 수 있다.
2. **데이터 주입 필수:** 정적 페이지라고 HTML만 덜렁 만들면 안 된다. 클라이언트에서 JS가 로드될 때 하이드레이션이 깨지지 않으려면 `window.__INITIAL_DATA__`도 스크립트 태그로 심어줘야 한다.
3. **템플릿 치환:** 거창한 파서가 필요한 게 아니었다. 그냥 `string.replace`로 구멍 뚫어놓은 주석(``)을 채워 넣으니 끝. 간단하지만 확실한 방법이다.

---

## 주요 트러블슈팅: 실전에서 마주한 벽들

### 1. 메모리 오염: "아니 왜 A 상품 페이지에 B 상품 정보가 보여?"

E2E 테스트를 돌리는데 이상한 현상이 발생했다. 여러 페이지를 동시에 테스트하면 데이터가 꼬이는 거다.

**원인:**

```javascript
// 전역 변수를 썼더니...
let currentProduct = null;

function renderProduct() {
  // 여러 요청이 동시에 들어오면 currentProduct가 계속 덮어씌워짐!
}

```

**교훈:** 서버에서 전역 변수는 독이다. 요청마다 독립적인 컨텍스트를 만들어야 한다.

### 2. 윈도우의 배신: "아니 왜 서버가 하나만 켜져?"

맥북으로 개발할 땐 평화로웠다. `package.json` 스크립트에 `&`만 붙이면 서버 5개(CSR, SSR, SSG Preview 등)가 알아서 뒤에서(Background) 잘 돌아갔으니까.

그런데 윈도우 데스크탑으로 환경을 옮기자마자 테스트가 다 터졌다.

**증상:**
`pnpm run serve:test`를 치면 첫 번째 서버(dev)만 켜지고 터미널이 멍하니 멈춰버린다. 뒤따라 켜져야 할 4개의 서버는 소식도 없고, Playwright는 "서버 언제 켜짐?" 하다가 타임아웃으로 사망.

**알고 보니:**
쉘(Shell)마다 `&`의 의미가 달랐다.

* **Mac/Linux:** "야, 이거 백그라운드에서 돌려!" (병렬 실행)
* **Windows(CMD):** "이거 다 끝나면 다음 거 해!" (순차 실행)

서버는 원래 종료가 안 되잖아? 그러니까 윈도우는 첫 번째 서버가 꺼질 때까지 영원히 기다리고 있었던 거다. 하...

**해결:**
OS 눈치 보지 말고 도구를 쓰자. `concurrently` 라이브러리를 도입했다.

```json
// 변경 전 (맥에서만 행복함)
"serve:test": "pnpm run dev & pnpm run serve:ssr & ..."

// 변경 후 (모두가 행복함)
"serve:test": "concurrently \"pnpm run dev\" \"pnpm run serve:ssr\" ..."

```

이제 윈도우에서도 명령어 한 방에 서버 5개가 아주 예쁘게 뜬다. Playwright도 드디어 밥값을 하기 시작했다.

---

## 렌더링 방식 선택 기준

이번 과제를 통해 각 방식을 언제 써야 하는지 명확히 이해하게 되었다.

### SSG: "멀리가지마 니 취향은 내가알아 가까운 곳에 준비해놨어"

**언제 쓸까:**

* 상품 상세 페이지 (내용이 자주 안 바뀜) -> 취향이 자주 바뀌면 곤란
* 블로그 포스트
* 랜딩 페이지

**왜 좋을까:**

* 미리 만들어두니까 가장 빠름
* CDN에서 바로 서빙 가능
* 서버 부하 거의 없음

**단점:**

* 상품이 추가되면 다시 빌드해야 함
* 실시간 데이터 반영 불가

### SSR: "SEO가 중요할 때"

**언제 쓸까:**

* 검색 결과 페이지 (사용자마다 다름)
* 뉴스 사이트 (최신 정보 중요)
* 개인화된 홈 화면

**왜 좋을까:**

* 검색 엔진이 내용을 읽을 수 있음
* 초기 로딩이 빠름 (사용자 입장)

**단점:**

* 서버 부하가 큼
* 캐싱 전략 필요

### CSR: "대시보드나 관리자 페이지"

**언제 쓸까:**

* SEO가 필요 없는 페이지
* 빠른 인터랙션이 중요한 경우
* 관리자 페이지

**왜 좋을까:**

* 페이지 전환이 순식간
* 서버 부하 적음
* 개발이 단순함

**단점:**

* SEO 불리
* 초기 로딩 느림

---

## 겪으면서 깨달은 것들

### "아, 이래서 프레임워크가 필요하구나"

직접 구현해보니 Next.js나 Remix가 왜 존재하는지 뼈저리게 느꼈다.

프레임워크가 자동으로 해주는 것들:

* 서버/클라이언트 코드 분리
* 라우팅과 데이터 패칭 통합
* 하이드레이션 자동화
* 빌드 최적화

이걸 다 수동으로 하려니 정말 복잡했다.

### "SSR이 만능은 아니다"

처음엔 "SSR이 무조건 좋은 거 아니야?"라고 생각했다.

하지만 직접 구현해보니:

* 서버 부하가 생각보다 크다
* 캐싱 전략이 복잡하다
* 디버깅이 어렵다 (서버? 클라이언트?)

**결론:** 상황에 맞게 SSG/SSR/CSR을 섞어 쓰는 게 답이다.

### "테스트의 중요성"

57개의 E2E 테스트를 하나씩 통과시키면서 느꼈다.

**테스트가 없었다면:**

* 리팩토링이 무서웠을 것
* 회귀 버그를 못 잡았을 것
* 배포가 두려웠을 것

테스트는 귀찮지만, 복잡한 시스템에서는 필수다.

---

## 앞으로의 계획

### 성능 최적화

현재 SSG 빌드가 너무 오래 걸린다. 다음에는:

* 변경된 페이지만 재빌드
* 병렬 처리로 빌드 시간 단축
* 이미지 최적화 추가

### 더 나은 하이드레이션

현재 방식은 전체를 다시 렌더링한다. 개선하려면:

* 부분 하이드레이션 
* 스트리밍 SSR 

---

## 마치며

"바닐라 JS로 SSR을 구현한다"는 말이 처음엔 말도 안 되는 소리처럼 들렸다.

하지만 직접 해보니, 프레임워크가 숨겨주던 복잡함의 실체를 볼 수 있었다. 그리고 그 복잡함을 이해하고 나니, 프레임워크를 사용할 때도 훨씬 자신감 있게 쓸 수 있을 것 같다.

**가장 큰 수확:** "왜?"라는 질문에 답할 수 있게 되었다.

* 왜 Next.js는 이렇게 동작하는가?
* 왜 하이드레이션 에러가 나는가? -> 최근에 6기 항해 기술블로그를 7기 API로 마이그레이션 후 배포하려고 작업중인데, 하이드레이션 에러로 인해서 페이지가 두개 생성되고 있음. 그걸 개선하는데에 큰 도움이 될 것 같다.
* 왜 SSG와 SSR을 섞어 쓰는가?

이제는 문서를 읽어도 아, 이 NEXT HOOK이 내가 고민했던 그 로직을 대신해주는 구나 하고 이해가 수월하게 됩니다.

**다음 프로젝트에서는:** 이번에 배운 걸 바탕으로 Next.js나 Remix를 깊이 있게 활용하고 싶다. 내부 동작을 이해하고 있으니, 더 효율적으로 시작해 볼 수 있을 것 같다.

---

## 리뷰 받고 싶은 내용

# Next.js라는 '마법'의 대가와 커스텀 구현의 가치

### 배경

이번 과제를 통해 Next.js가 자동으로 처리해 주던 하이드레이션과 라우팅 시스템을 바닐라 JS와 React로 직접 구현해 보았습니다. 이 과정을 통해 프레임워크가 뒤단에서 얼마나 복잡한 일들을 대신 수행하고 있었는지 뼈저리게 느낄 수 있었습니다.

하지만 동시에 의문이 들었습니다. "내가 직접 짠 코드가 과연 Next.js보다 효율적일까?" 혹은 반대로 "간단한 랜딩 페이지 하나를 위해 Next.js라는 거대한 도구를 가져오는 것이 맞을까?" 하는 고민입니다.

### 질문 1. 프레임워크 도입의 기준

"직접 구현의 복잡함을 경험해 보니 Next.js의 편리함이 감사했지만, 한편으론 간단한 프로젝트(랜딩 페이지, 마케팅 페이지 등)에서도 무조건 Next.js를 표준으로 삼는 것이 맞는지 의문이 들었습니다.

팀 내에서 기술 스택을 선정하실 때, **'프레임워크가 가져오는 무거움이나 오버헤드'**와 **'직접 구현했을 때 발생하는 유지보수 비용'** 사이에서 저울질하는 구체적인 기준이 있으신가요? 기술 부채를 피하기 위한 멘토님만의 기술 스택 선정 철학이 궁금합니다."

---

### 질문 2. "SEO를 위해 Next.js를 쓴다"는 저와 비슷한 초보들의 통념에 대한 반론 

많은 이력서나 기술 블로그에서 **'SEO 최적화를 위해 React에서 Next.js로 마이그레이션했다'** 는 내용을 봅니다. 하지만 제가 공부한 바로는 최근의 Google 봇은 자바스크립트 실행 능력이 뛰어나 CSR(React)도 크롤링이 가능하고, `React Helmet` 같은 대안도 있는 것으로 알고 있습니다.

1. **순수 React의 한계:** 현업에서 느끼시기에, 순수 React에 메타 태그 라이브러리 등을 조합하는 방식은 Next.js의 SSR/SSG에 비해 SEO 경쟁력이 현저히 떨어지나요? (예: 네이버/카카오 등 로컬 검색 엔진의 한계, Social Share 미리보기 등)
2. **맹목적인 도입에 대한 견해:** SEO가 중요한 서비스라면, 성능 최적화나 아키텍처의 복잡도를 감수하더라도 **'뒤도 돌아보지 말고 Next.js'** 가 정답인가요? 아니면 React로도 충분히 SEO 점수를 방어할 수 있는 전략이나 사례가 있나요?

SEO 때문에 Next.js를 도입했다는 말에 대해, 엔지니어로서 어떤 검증 질문을 던져야 진짜 실력을 가려낼 수 있을지 궁금합니다.

